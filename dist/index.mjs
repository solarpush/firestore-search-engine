class t{constructor(t,e,n){this.firestoreInstance=t,this.config=e,this.props=n}async execute(){const t=function(t,e=30){var n,s;if(t.length>e)throw new Error("Input up to 50 Char");const r=new Set,i=[4,5,6],o={a:["z","q","s"],z:["a","e","s"],e:["z","r","d"],r:["e","t","f"],t:["r","y","g"],y:["t","u","h"],u:["y","i","j"],i:["u","o","k"],o:["i","p","l"],p:["o","m"],q:["a","s","w"],s:["a","z","d","q"],d:["s","e","f"],f:["d","r","g"],g:["f","t","h"],h:["g","y","j"],j:["h","u","k"],k:["j","i","l"],l:["k","o","m"],m:["l","p"]};for(const e of i)for(let i=0;i<=t.length-e;i++){const c=t.slice(i,i+e);if(c.length>=3){const t=c[0];o[t]&&o[t].forEach((t=>{const e=t+c.slice(1);r.add(e)})),null===(n=o[t])||void 0===n||n.forEach((t=>{const e=t+c;r.add(e)})),r.add(c.slice(1))}const a=c[c.length-1];c.length>=3&&o[a]&&(o[a].forEach((t=>{const e=c.slice(0,-1)+t;r.add(e)})),null===(s=o[a])||void 0===s||s.forEach((t=>{const e=c+t;r.add(e)})),r.add(c.slice(0,-1)))}return r}(this.props.inputField,this.props.wordMaxLength);return await this.saveWithLimitedKeywords(this.props.returnedFields,Array.from(t))}async saveWithLimitedKeywords(t,e){const n=this.firestoreInstance.bulkWriter();await this.cleanOldIndexes(t,n);const s=[];for(let t=0;t<e.length;t+=800)s.push(e.slice(t,t+800));for(let e=0;e<s.length;e++)n.create(this.firestoreInstance.collection(this.config.collection).doc(),{search_keywords:s[e],...t}),e%500==0&&await n.flush();await n.close()}async cleanOldIndexes(t,e){const{indexedDocumentPath:n}=t,s=await this.firestoreInstance.collection(this.config.collection).where("indexedDocumentPath","==",n).get();if(!s.empty){for(let t=0;t<s.docs.length;t++)e.delete(s.docs[t].ref),t%500==0&&await e.flush();await e.flush()}}}function e(t,e){const n=Array.from({length:t.length+1},((t,n)=>[n,...Array(e.length).fill(0)]));for(let t=0;t<=e.length;t++)n[0][t]=t;for(let s=1;s<=t.length;s++)for(let r=1;r<=e.length;r++){const i=t[s-1]===e[r-1]?0:1;n[s][r]=Math.min(n[s-1][r]+1,n[s][r-1]+1,n[s-1][r-1]+i)}return n[t.length][e.length]}class n{constructor(t,e,n){this.firestoreInstance=t,this.config=e,this.props=n}async execute(){return await this.search(this.props.fieldValue)}async search(t){const n=function(t,e=3,n=8){const s=[];t.split(" ").forEach((t=>{for(let r=1;r<=Math.min(t.trim().length,n);r++)r<=e||s.push(t.trim().substring(0,r).toLowerCase())}));for(let r=1;r<=Math.min(t.length,n);r++)r<=e||s.push(t.substring(0,r).toLowerCase());return s}(t),s=await this.firestoreInstance.collection(this.config.collection).where("search_keywords","array-contains-any",[...n]).get();if(s.empty)return[];const r=new Set,i=[];for(const n of s.docs){const s=n.data(),{search_keywords:o,...c}=s,a=s.indexedDocumentPath;o.some((n=>t.split(" ").some((t=>e(t,n)<=2))))&&!r.has(a)&&(r.add(a),i.push(c))}return i}}class s{constructor(t,e){if(this.firestoreInstance=t,this.config=e,this.firestoreInstance.settings({ignoreUndefinedProperties:!0}),this.config.collection.length<1)throw new Error("collectionName is required and must be a non-empty string.")}async search(t){if("string"!=typeof t.fieldValue||0===t.fieldValue.length)throw new Error("fieldValue is required and must be a non-empty string.");return await new n(this.firestoreInstance,this.config,t).execute()}async indexes(e){if("string"!=typeof e.inputField||0===e.inputField.length)throw new Error("fieldValue is required and must be a non-empty string.");return await new t(this.firestoreInstance,this.config,e).execute()}}export{s as FirestoreSearchEngine};
//# sourceMappingURL=index.mjs.map
