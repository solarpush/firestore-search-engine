class t{constructor(t,e,s){this.firestoreInstance=t,this.config=e,this.props=s}async execute(){const t=function(t,e=30){var s,n;if(t.length>e)throw new Error("Input up to 50 Char");const r=new Set,i=t.length>4?[4,5,6]:[3,4],o={a:["z","q","s"],z:["a","e","s"],e:["z","r","d"],r:["e","t","f"],t:["r","y","g"],y:["t","u","h"],u:["y","i","j"],i:["u","o","k"],o:["i","p","l"],p:["o","m"],q:["a","s","w"],s:["a","z","d","q"],d:["s","e","f"],f:["d","r","g"],g:["f","t","h"],h:["g","y","j"],j:["h","u","k"],k:["j","i","l"],l:["k","o","m"],m:["l","p"]};for(const e of i)for(let i=0;i<=t.length-e;i++){const a=t.slice(i,i+e);if(a.length>=3){const t=a[0];o[t]&&o[t].forEach((t=>{const e=t+a.slice(1);r.add(e.trim())})),null===(s=o[t])||void 0===s||s.forEach((t=>{const e=t+a;r.add(e.trim())})),r.add(a.slice(1).trim())}const c=a[a.length-1];a.length>=3&&o[c]&&(o[c].forEach((t=>{const e=a.slice(0,-1)+t;r.add(e.trim())})),null===(n=o[c])||void 0===n||n.forEach((t=>{const e=a+t;r.add(e.trim())})),r.add(a.slice(0,-1).trim()))}return r}(this.props.inputField,this.props.wordMaxLength);return await this.saveWithLimitedKeywords(this.props.returnedFields,Array.from(t))}async saveWithLimitedKeywords(t,e){const s=this.firestoreInstance.bulkWriter();await this.cleanOldIndexes(t,s);const n=[];for(let t=0;t<e.length;t+=800)n.push(e.slice(t,t+800));for(let e=0;e<n.length;e++)s.create(this.firestoreInstance.collection(this.config.collection).doc(),{search_keywords:n[e],...t}),e%500==0&&await s.flush();await s.close()}async cleanOldIndexes(t,e){const{indexedDocumentPath:s}=t,n=await this.firestoreInstance.collection(this.config.collection).where("indexedDocumentPath","==",s).get();if(!n.empty){for(let t=0;t<n.docs.length;t++)e.delete(n.docs[t].ref),t%500==0&&await e.flush();await e.flush()}}}function e(t,e){const s=Array.from({length:t.length+1},((t,s)=>[s,...Array(e.length).fill(0)]));for(let t=0;t<=e.length;t++)s[0][t]=t;for(let n=1;n<=t.length;n++)for(let r=1;r<=e.length;r++){const i=t[n-1]===e[r-1]?0:1;s[n][r]=Math.min(s[n-1][r]+1,s[n][r-1]+1,s[n-1][r-1]+i)}return s[t.length][e.length]}class s{constructor(t,e,s){this.firestoreInstance=t,this.config=e,this.props=s,s.limit||(this.props.limit=20)}async execute(){return await this.search(this.props.fieldValue)}async search(t){const s=function(t,e=3,s=8){const n=new Set;t.trim().split(" ").forEach((t=>{for(let r=1;r<=Math.min(t.trim().length,s);r++)r<=e||n.add(t.trim().substring(0,r).toLowerCase())}));for(let r=1;r<=Math.min(t.trim().length,s);r++)r<=e||n.add(t.trim().substring(0,r).toLowerCase());return console.log(n),Array.from(n)}(t),n=await this.firestoreInstance.collection(this.config.collection).where("search_keywords","array-contains-any",[...s]).get();if(n.empty)return[];const r=new Set,i=[];for(const s of n.docs){const n=s.data(),{search_keywords:o,...a}=n,c=n.indexedDocumentPath;o.forEach((s=>{const n=t.split(" ");let o=!1,l=0,h=0;for(const t of n){const n=e(t,s);n<=2&&(o=!0,l=Math.min(n,l||1/0)),h+=n}console.log(h,o,t,n),o&&h<=6&&!r.has(c)&&(r.add(c),i.push({doc:a,relevance:l}))}))}i.sort(((t,e)=>t.relevance-e.relevance));return i.slice(0,this.props.limit).map((t=>t.doc))}}class n{constructor(t,e){if(this.firestoreInstance=t,this.config=e,this.firestoreInstance.settings({ignoreUndefinedProperties:!0}),this.config.collection.length<1)throw new Error("collectionName is required and must be a non-empty string.")}async search(t){if("string"!=typeof t.fieldValue||0===t.fieldValue.length)throw new Error("fieldValue is required and must be a non-empty string.");return await new s(this.firestoreInstance,this.config,t).execute()}async indexes(e){if("string"!=typeof e.inputField||0===e.inputField.length)throw new Error("fieldValue is required and must be a non-empty string.");return await new t(this.firestoreInstance,this.config,e).execute()}async expressWrapper(t,e="/search"){if(!e||!e.startsWith("/"))throw new Error("Path must be in the format '/search'");return t.get(`${e}/:searchValue`,(async(t,e)=>{const{searchValue:s}=t.params;if(!s||!s.length||s.length<3)return void e.json([]);const n=await this.search({fieldValue:s});e.json(n)})),t}onRequestWrapper(){return async(t,e)=>{const s=t.query.searchValue;if(!s||"string"!=typeof s||s.length<3)return void e.json([]);const n=await this.search({fieldValue:s});e.json(n)}}}export{n as FirestoreSearchEngine};
//# sourceMappingURL=index.mjs.map
