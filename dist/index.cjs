"use strict";class t{constructor(t,e,s){this.firestoreInstance=t,this.config=e,this.props=s}async execute(){const t=function(t,e=30){var s,r;if(t.length>e)throw new Error("Input up to 50 Char");const n=new Set,i=t.length>4?[4,5,6]:[3,4],o={a:["z","q","s"],z:["a","e","s"],e:["z","r","d"],r:["e","t","f"],t:["r","y","g"],y:["t","u","h"],u:["y","i","j"],i:["u","o","k"],o:["i","p","l"],p:["o","m"],q:["a","s","w"],s:["a","z","d","q"],d:["s","e","f"],f:["d","r","g"],g:["f","t","h"],h:["g","y","j"],j:["h","u","k"],k:["j","i","l"],l:["k","o","m"],m:["l","p"]};for(const e of i)for(let i=0;i<=t.length-e;i++){const a=t.slice(i,i+e);if(a.length>=3){const t=a[0];o[t]&&o[t].forEach((t=>{const e=t+a.slice(1);n.add(e.trim())})),null===(s=o[t])||void 0===s||s.forEach((t=>{const e=t+a;n.add(e.trim())})),n.add(a.slice(1).trim())}const c=a[a.length-1];a.length>=3&&o[c]&&(o[c].forEach((t=>{const e=a.slice(0,-1)+t;n.add(e.trim())})),null===(r=o[c])||void 0===r||r.forEach((t=>{const e=a+t;n.add(e.trim())})),n.add(a.slice(0,-1).trim()))}return n}(this.props.inputField,this.props.wordMaxLength);return await this.saveWithLimitedKeywords(this.props.returnedFields,Array.from(t))}async saveWithLimitedKeywords(t,e){const s=this.firestoreInstance.bulkWriter();await this.cleanOldIndexes(t,s);const r=[];for(let t=0;t<e.length;t+=800)r.push(e.slice(t,t+800));for(let e=0;e<r.length;e++)s.create(this.firestoreInstance.collection(this.config.collection).doc(),{search_keywords:r[e],...t}),e%500==0&&await s.flush();await s.close()}async cleanOldIndexes(t,e){const{indexedDocumentPath:s}=t,r=await this.firestoreInstance.collection(this.config.collection).where("indexedDocumentPath","==",s).get();if(!r.empty){for(let t=0;t<r.docs.length;t++)e.delete(r.docs[t].ref),t%500==0&&await e.flush();await e.flush()}}}function e(t,e){const s=Array.from({length:t.length+1},((t,s)=>[s,...Array(e.length).fill(0)]));for(let t=0;t<=e.length;t++)s[0][t]=t;for(let r=1;r<=t.length;r++)for(let n=1;n<=e.length;n++){const i=t[r-1]===e[n-1]?0:1;s[r][n]=Math.min(s[r-1][n]+1,s[r][n-1]+1,s[r-1][n-1]+i)}return s[t.length][e.length]}class s{constructor(t,e,s){this.firestoreInstance=t,this.config=e,this.props=s,s.limit||(this.props.limit=20)}async execute(){return await this.search(this.props.fieldValue)}async search(t){const s=function(t,e=3,s=8){const r=new Set;t.trim().split(" ").forEach((t=>{for(let n=1;n<=Math.min(t.trim().length,s);n++)n<=e||r.add(t.trim().substring(0,n).toLowerCase())}));for(let n=1;n<=Math.min(t.trim().length,s);n++)n<=e||r.add(t.trim().substring(0,n).toLowerCase());return console.log(r),Array.from(r)}(t),r=await this.firestoreInstance.collection(this.config.collection).where("search_keywords","array-contains-any",[...s]).get();if(r.empty)return[];const n=new Set,i=[];for(const s of r.docs){const r=s.data(),{search_keywords:o,...a}=r,c=r.indexedDocumentPath;o.forEach((s=>{const r=t.split(" ");let o=!1,l=0,h=0;for(const t of r){const r=e(t,s);r<=2&&(o=!0,l=Math.min(r,l||1/0)),h+=r}console.log(h,o,t,r),o&&h<=6&&!n.has(c)&&(n.add(c),i.push({doc:a,relevance:l}))}))}i.sort(((t,e)=>t.relevance-e.relevance));return i.slice(0,this.props.limit).map((t=>t.doc))}}exports.FirestoreSearchEngine=class{constructor(t,e){if(this.firestoreInstance=t,this.config=e,this.firestoreInstance.settings({ignoreUndefinedProperties:!0}),this.config.collection.length<1)throw new Error("collectionName is required and must be a non-empty string.")}async search(t){if("string"!=typeof t.fieldValue||0===t.fieldValue.length)throw new Error("fieldValue is required and must be a non-empty string.");return await new s(this.firestoreInstance,this.config,t).execute()}async indexes(e){if("string"!=typeof e.inputField||0===e.inputField.length)throw new Error("fieldValue is required and must be a non-empty string.");return await new t(this.firestoreInstance,this.config,e).execute()}async expressWrapper(t,e="/search"){if(!e||!e.startsWith("/"))throw new Error("Path must be in the format '/search'");return t.get(`${e}/:searchValue`,(async(t,e)=>{const{searchValue:s}=t.params;if(!s||!s.length||s.length<3)return void e.json([]);const r=await this.search({fieldValue:s});e.json(r)})),t}onRequestWrapper(){return async(t,e)=>{const s=t.query.searchValue;if(!s||"string"!=typeof s||s.length<3)return void e.json([]);const r=await this.search({fieldValue:s});e.json(r)}}};
//# sourceMappingURL=index.cjs.map
